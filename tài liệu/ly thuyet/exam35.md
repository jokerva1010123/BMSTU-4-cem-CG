# 35. Алгоритм определения  видимых  поверхностей путем трассировки лучей.

## Трассировка лучей

Трассировка лучей - метод грубой силы (метод, не учитывающий специфику обрабатываемого объекта).  

**Главная идея:** наблюдатель видит объект непосредством испускаемого неким источником света, который падает на этот объект и затем как то видит этот объект. Из огромного числа лучей, выпущенных источником, лишь небольшая часть дойдет до наблюдателя, поэтому отслеживать лучи таким образом неэффективно. Аппель предложил трассировать (то есть отслеживать) лучи в обратном направлении, т.е. от наблюдателя к объекту

![1](https://camo.githubusercontent.com/d99d9c98164175af25716cd82a4d4486cfcb45a9/68747470733a2f2f73756e312d38342e757365726170692e636f6d2f53345537526659556e6c6e2d7354377552374347774b7877545667574e5a586242486a7238772f2d6353464676496f7458492e6a7067)

* Предполагается, что сцена преобразовна в **пространство изображений**. 
* Считается, что точка зрения или наблюдатель находится  бесконечности на положительной полуоси z, поэтому все лучи параллельны оси z.
* Каждый луч проходит проходит через центр пикселя на растре до сцены.
* Траектория каждого луча отслеживается, чтобы определить, какие именно объекты пересекаются с данным лучом. Необходимо проверить пересечение каждого объекта с каждым лучом. 
* Пересечение с zmax представляет видимую поверхность для данного пикселя

![2](https://camo.githubusercontent.com/33c57adac7e619d7970e26d8552c22a9366d5c8c/68747470733a2f2f73756e312d31342e757365726170692e636f6d2f7567326d4e354c6d6a6a4163567436515a5361753230376d346b544776774631364d64684b512f4e4a6478334c7965444d452e6a7067)

**Случай, если точка расположена не в бексконечности** (перспективная проекция).

* Предполагается, что наблюдатель так же находится на OZ
* Растр перпендикулярен OZ 
* Задача состоит в том, чтобы построить одноточечную центральную проекцию на картинную плоскость.

## Определение пересечений

Понятно, что нужно вычислять множество точек пересечений (около 75 - 95% всего времени). Поэтому, для ускорения процесса, необходимо иметь важные критерии, чтобы исключить из процесса заведомо лишние объекты.

Одно из решений - погружение объектов в выпуклую "оболочку". Например сферическую, или в форме параллепипеда. Таким образом, можем проверить пересечения луча с объектом (оболочкой).  
Если луч не пересекает оболочки, то объект можно откинуть, и не искать пересечения луча и этого объекта.

## Сферический тест

Сферическая оболочка: самый простой вариант, но может оказаться неэффективным. Если расстояние от центра сферической оболочки до луча превосходит радиус этой сферы, то луч не пересекает оболочки.  
Пусть прямая задана как ``` P1(x1, y1, z1)``` и ```P2(x2, y2, z2)```.

![3](https://camo.githubusercontent.com/1a457e115b0032f448a73aa235e6cede2081dc98/68747470733a2f2f73756e312d31362e757365726170692e636f6d2f3331707a6f4f6c734e445f556f6344424c58716e7631557347336545364b654b324e717165772f6e546752505a4e2d4458732e6a7067)  
![4](https://camo.githubusercontent.com/8c773bf43652e10604d5692eb7d74abeab7eb101/68747470733a2f2f73756e312d39302e757365726170692e636f6d2f56793777416a53515f6b316a706d326e32486f59414134566a32504663484333654d475677412f6d683766673145516d4a592e6a7067)

## Габаритный тест

**Тест при прямоугольной оболочке**

Удобно провести преобразование, которое совместит трассирующий луч с OZ. Тогда достаточно будет исследовать xmin, xmax, ymin и ymax. Если они меняются в каждой паре, то зафиксируем возможное пересечение.

* Выполнение габаритного теста с прямоугольной оболочкой в трехмерном пространстве требует большого объема вычислений.
* Следует проверить пересечение по меньшей мере с тремя бексконечностями плоскостями (**я не понял о чем речь**)
* Более медленный, чем со сферической оболочкой.

## Алгоритм  

```
1. Создание списка объектов. 
   а) Полное описание объекта (тип, пов-ть, хар-ки)
   б) Описание сферической оболочки.
   в) Флаг прямоугольной оболочки (если нужны габаритные тесты)
2. Для каждого луча выполнить:
   2.1. Для каждого объекта выполнить тест со сферич. оболочкой. 
        Если объект проходит тест, то заносим его в список активных объектов.
   2.2. Если список пуст, изобразить пиксель цветом фона. Иначе,
        перенос и поворот луча для совмещения с OZ (запомнить преобразование)
3. Для каждого активного объекта:
   3.1. Если поднят флаг прямоугольной оболочки, преобразовать эту оболочку в СК луча
        и выполнить соответствующий тест.
   3.2. Преобразовать объект в СК луча, определить его пересечение с лучом. 
        Занести все пересечения в список пересечений.
4. Если список пуст, то ставим пиксель цветом фона. Иначе, определить zmax
   для списка пересечений. 
5. Вычислить обратное преорбазование. Определяем с его помощью т. пересечения в
   исходной СК. Нарисовать пиксель с атрибутами объекта и модели освещения.
   // Пятый пункт для определения видимости не нужен.
```

## Возможные модификации

**1. Кластерные группы пространственно связанных объектов**  
Название ебнутое, но вроде не сложно.

**Суть:** вводим сферические оболочки для групп (наборов) связанных между с собой объектов. (например: корзина внутри которой находятся котики). Такие сферические оболочки называются **сферическим кластером** - такой кластер охватывает два и более объектов. Так же вводят общую оболочку на всю объекты. Если очень хочется, то вводим прямоугольные кластеры (вместо сферических). 

После всех этих манипуляций, просто обрабатываем все в иерархическом порядке. Если луч не пересекает сферический кластер, то выкидываем весь кластер из расмотрения. Если пересекает, то рекурсивно выполняется, пока не будут обработаны все объекты. 

**2. Упорядочение по приоритету.** 
Используется для сокращения числа объектов, для которых вычисляются пересечения. 

После рассмотрения всех объектов, преобразованный список пересеченных объектов упорядочивается по приоритету глубины. Для определения приоритетного порядка можно использовать центры сферичесикх оболочек или zmax (zmin) прямоугольных оболочек. Далее, определяют список активных объектов (по идеям [алгоритма со списком приоритетов](./exam33)), далее так же трассировка как в обычном алгоритме, только уже для активных объектов. 


**Следующий вопрос:**  [36. Построение реалистических изображений. Физические и  психологические  факторы,  учитываемые  при  создании реалистичных изображений. Простая модель освещения.](./exam36)


**Предыдущий вопрос:**  [34. Алгоритм построчного сканирования, использующий Z буфер. Интервальные методы построчного сканирования (основные предпосылки).](./exam34)
