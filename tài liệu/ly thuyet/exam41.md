# 41. Учет прозрачности в модели освещения. Учет прозрачности в  алгоритмах удаления невидимых поверхностей.

## Закон Снеллиуса

В основных моделях освещения и алгоритмах удаления невидимых линий и поверхностей рассматриваются только непрозрачные поверхности и объекты. Однако существуют и прозрачные объекты, пропускающие свет, например, такие, как стакан, ваза, окно автомобиля, вода. При переходе из одной среды в другую, например из воздуха в воду, световой луч преломляется; поэтому торчащая из воды палка кажется согнутой. Преломление рассчитывается по закону Снеллиуса, который утверждает, что падающий и преломляющий лучи лежат в одной плоскости, а углы падения и преломления связаны формулой

<a href="https://www.codecogs.com/eqnedit.php?latex=\eta_1sin\theta&space;=&space;\eta_2sin\theta'" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\eta_1sin\theta&space;=&space;\eta_2sin\theta'" title="\eta_1sin\theta = \eta_2sin\theta'" /></a>

В простейших реализациях эффекты прозрачности преломления вообще не рассматриваются. Кроме того, не принимается во внимание, как путь, пройденный лучом в среде, влияет на его интенсивность. Самые ранние разработки в этой области принадлежат Ньюэлу. Простое пропускание света можно встроить в любой алгоритм удаления невидимых поверхностей, кроме алгоритма с z-буфером.

Существует два варианта аппроксимации - линейная и нелинейная.

## Линейная

Прозрачные многоугольники или поверхности помечаются, и если видимая грань прозрачна, то в буфер кадра записывается линейная комбинация двух ближайших поверхностей. При этом интенсивность

<a href="https://www.codecogs.com/eqnedit.php?latex=I&space;=&space;tI_1&plus;(1-t)I_2,&space;0&space;\le&space;t&space;\le&space;1" target="_blank"><img src="https://latex.codecogs.com/svg.latex?I&space;=&space;tI_1&plus;(1-t)I_2,&space;0&space;\le&space;t&space;\le&space;1" title="I = tI_1+(1-t)I_2, 0 \le t \le 1" /></a>

где I<sub>1</sub> - видимая поверхность, I<sub>2</sub> - поверхность, расположенная непосредственно за ней, t - коэффициент прозрачности I<sub>1</sub>. Если поверхность совершенно прозрачна, то t = 0, а если непрозрачна, то t = 1. Если I<sub>2</sub> тоже прозрачна, то алгоритм применяется рекуррентно, пока не встретится непрозрачная поверхность или фон. Если многоугольники записываются в буфер кадра в соответствии с приоритетами глубины, как в алгоритме Ньюэла-Санча, тогда I<sub>2</sub> будет соответствовать значению, записанному в буфер кадра, а I<sub>1</sub> - текущей поверхности.

## Нелинейная

Для криволинейных поверхностей, например, таких, как ваза или бутылка, линейной аппроксимации недостаточно, так как вблизи контурных линий прозрачность уменьшается из-за толщины материала. Чтобы точнее изобразить это явление, Кэй предложил несложную нелинейную аппроксимацию на основе z-составляющей нормали к поверхности. В частности, коэффициент прозрачности

<a href="https://www.codecogs.com/eqnedit.php?latex=t&space;=&space;t_{min}&space;&plus;&space;(t_{max}&space;-&space;t_{min})[1-(1-|n_z|^p)]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?t&space;=&space;t_{min}&space;&plus;&space;(t_{max}&space;-&space;t_{min})[1-(1-|n_z|^p)]" title="t = t_{min} + (t_{max} - t_{min})[1-(1-|n_z|^p)]" /></a>

где t<sub>min</sub> и t<sub>max</sub> - минимальная и максимальная прозрачность объекта, n<sub>z</sub> есть z- составляющая единичной нормали к поверхности, р - коэффициент степени прозрачности, t - прозрачность пиксела или точки объекта.

## Учет прозрачности в алгоритмах

Простое пропускание света можно встроить в любой алгоритм удаления невидимых поверхностей, кроме алгоритма с z-буфером.

Для алгоритма, использующего z-буфер, последовательность действий такова:

Для каждого многоугольника:
* если многоугольник прозрачен, то внести его в список прозрачных многоугольников;
* если многоугольник непрозрачен и z > z-буфер , то записать его в буфер кадра для непрозрачных многоугольников и скорректировать этот буфер.

Для каждого многоугольника из списка прозрачных многоугольников:
* если z > z-буфер , то прибавить его коэффициент прозрачности к значению, содержащемуся в буфере весовых коэффициентов прозрачности;
* прибавить его интенсивность к значению, содержащемуся в буфере интенсивности прозрачности, в соответствии с правилом

<a href="https://www.codecogs.com/eqnedit.php?latex=I_{bn}&space;=&space;I_{b0}t_{b0}&space;&plus;&space;I_ct_c" target="_blank"><img src="https://latex.codecogs.com/svg.latex?I_{bn}&space;=&space;I_{b0}t_{b0}&space;&plus;&space;I_ct_c" title="I_{bn} = I_{b0}t_{b0} + I_ct_c" /></a>

где I<sub>bn</sub> - новое значение интенсивности, I<sub>b0</sub> - старое значение интенсивности, записанное в буфере интенсивности прозрачности, I<sub>с</sub> - интенсивность текущего многоугольника, t<sub>b0</sub> - старый коэффициент прозрачности из буфера весовых коэффициентов прозрачности, t<sub>с</sub> - коэффициент прозрачности текущего многоугольника. Таким образом, получается взвешенная сумма интенсивностей всех прозрачных многоугольников, находящихся перед ближайшим непрозрачным многоугольником.

Объединим буферы интенсивности для прозрачных и непрозрачных многоугольников в соответствии с правилом

<a href="https://www.codecogs.com/eqnedit.php?latex=I_{fb}&space;=&space;I_{b0}t_{b0}&space;&plus;&space;(1-t_{b0})I_{fb0}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?I_{fb}&space;=&space;I_{b0}t_{b0}&space;&plus;&space;(1-t_{b0})I_{fb0}" title="I_{fb} = I_{b0}t_{b0} + (1-t_{b0})I_{fb0}" /></a>

где I<sub>fb</sub> - окончательная интенсивность в буфере кадра для непрозрачных многоугольников, a I<sub>fb0</sub> - старое значение интенсивности в этом буфере.

Эту процедуру удобнее использовать в сочетании с алгоритмом построчного сканирования с z-буфером, поскольку для полного алгоритма с z- буфером требуется очень много памяти.

**Следующий вопрос:**  [42. Учет фактуры при создании реалистических изображений.](./exam42)


**Предыдущий вопрос:**  [40. Построение теней при создании реалистических изображений. Учет теней в алгоритмах удаления невидимых поверхностей.](./exam40)
