# 42. Учет фактуры при создании реалистических изображений.

Под фактурой, или текстурой, в компьютерной графике понимается детализация строения поверхности. Как правило, рассматривают два вида детализации. В первом случае на гладкую поверхность объекта наносят заданный рисунок (узор). В этом случае поверхность остается гладкой. Во втором случае ставится задача создания неровностей на поверхности, т.е. создания шероховатой поверхности.

## Проективные текстуры

Суть моделирования проективных тектсур заключается в том, что текстуры проецируются на поверхность параллельным переносом (плосоке проецирование), либо цилиндрическим и сферическим методами. Недостатки проективных текстур - большой объем памяти для хранения образцов текстур, небольшая гибкость и трудность текстурирования объектов сложной формы. В общем случае текстура проецируется на поверхность, которая затем проецируется на двумерный экран (картинную плосоксть). Таким образом, некое избражение (элемент текстуры) проецируется на поверхность объекта, а затем наблюдатель смотрит на неё уже из другой точки, то есть изображение снова проецируется уже с поверхности в точку положения наблюдателя.

Задается в некоторой (обычно двумерной) системе координат рисунок, подлежащий нанесению на трехмерную поверхность. Тогда для наложения заданного рисунка на поверхность необходимо найти функцию отображения или, другими словами, произвести преобразование координат. Проективным текстурам присущи определенные недостатки. Во-первых, для хранения используемых изображений требуется достаточно большой объем памяти. Во-вторых, они не обладают гибкостью, а, в-третьих, возможны большие сложности при подборе способа проектирования при нанесении рисунка на объекты сложной формы. На практике используют ограниченное количество вариантов проектирования: плоское (параллельное проектирование), цилиндрическое и сферическое.

## Процедурные текстуры

Процедурные (сплошные) текстуры - это тектсуры, описываемые математическими формулами. Такие текстуры не занимают в видеопамяти места, а создаются, например, пиксельным шейдером. Преимуществом процедурных текстур является неограниченный уровень детализации каждой тектсуры (пикселизации не будет, так как текстура всегда генерируется под необходимый для её отображения размер). Недостатком процедурных текстура можно назвать тот случай, когда подобранная функция является сложной, так как зависит от большого числа переменных.

Необходимо найти функцию C(X,Y,Z), определяющую для каждой точки поверхности цвет таким образом, чтобы он соответствовал цвету моделируемого материала (наносимого рисунка). Такой подход не требует больших затрат памяти и хорошо работает с поверхностями любой сложности. Но поскольку используемая функция зависит от большого количества параметров, то возникаютсложности в подборе этой функции, с другой стороны, изменение этих параметров позволяет легко изменять свойства текстуры.

## Неровности

Для того, чтобы поверхность казалась шероховатой, можно оцифровать фотографию нерегулярной фактуры и отобразить ее на поверхность. Однако при этом неровности будут восприниматься как нарисованные на гладкой поверхности, т.е. изображение будет не полностью реалистическим. Это связано с тем, что в векторе нормали к реальной шероховатой поверхности, а следовательно, в направлении вектора отражения,есть небольшая случайная составляющая. Этот факт и лег в основу способа моделирования неровностей на отображаемой поверхности. Пусть Q(X,Y) – уравнение поверхности, т.е. функция Q позволяет для каждой точки поверхности определить ее третью координату Z. В произвольной точке поверхности частные производные по направлениям X,Y лежат в плоскости, касательной к поверхности в этой точке. Нормаль в точке поверхности может определяться векторным произведением этих производных: 

<a href="https://www.codecogs.com/eqnedit.php?latex=N&space;=&space;[Q'_x,&space;Q'_y]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?N&space;=&space;[Q'_x,&space;Q'_y]" title="N = [Q'_x, Q'_y]" /></a>

Для создания шероховатой поверхности можно создать новую поверхность путем внесения возмущения в направлении нормали в точках поверхности. Пусть P(X,Y) – функция возмущения,тогда радиус-вектор точки на новой поверхности будет определяться из 

<a href="https://www.codecogs.com/eqnedit.php?latex=Q_n(X,&space;Y)&space;=&space;Q(X,&space;Y)&space;&plus;&space;\frac{P(X,&space;Y)N}{|N|}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?Q_n(X,&space;Y)&space;=&space;Q(X,&space;Y)&space;&plus;&space;\frac{P(X,&space;Y)N}{|N|}" title="Q_n(X, Y) = Q(X, Y) + \frac{P(X, Y)N}{|N|}" /></a>

Нормаль к новой возмущенной поверхности будет иметь вид:

<a href="https://www.codecogs.com/eqnedit.php?latex=N_n&space;=&space;[Q'_{nx},&space;Q'_{ny}]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?N_n&space;=&space;[Q'_{nx},&space;Q'_{ny}]" title="N_n = [Q'_{nx}, Q'_{ny}]" /></a>

Частные производные Q’nx , Q’ny вычисляются из следующих выражений:

<a href="https://www.codecogs.com/eqnedit.php?latex=Q'_nx&space;=&space;Q'_x&space;&plus;&space;\frac{P'_x(X,&space;Y)N}{|N|}&space;&plus;&space;\frac{P(X,&space;Y)Nx}{|N|}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?Q'_nx&space;=&space;Q'_x&space;&plus;&space;\frac{P'_x(X,&space;Y)N}{|N|}&space;&plus;&space;\frac{P(X,&space;Y)Nx}{|N|}" title="Q'_nx = Q'_x + \frac{P'_x(X, Y)N}{|N|} + \frac{P(X, Y)Nx}{|N|}" /></a>

<a href="https://www.codecogs.com/eqnedit.php?latex=Q'_ny&space;=&space;Q'_y&space;&plus;&space;\frac{P'_y(X,&space;Y)N}{|N|}&space;&plus;&space;\frac{P(X,&space;Y)Ny}{|N|}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?Q'_ny&space;=&space;Q'_y&space;&plus;&space;\frac{P'_y(X,&space;Y)N}{|N|}&space;&plus;&space;\frac{P(X,&space;Y)Ny}{|N|}" title="Q'_ny = Q'_y + \frac{P'_y(X, Y)N}{|N|} + \frac{P(X, Y)Ny}{|N|}" /></a>

Последними слагаемыми можно пренебречь, так как функция возмущения P(X,Y) - очень маленькая величина. Теперь можно записать выражение для вычисления нормали к возмущенной поверхности:

<a href="https://www.codecogs.com/eqnedit.php?latex=N_n&space;=&space;[Q'_nx,&space;Q'_ny]&space;&plus;&space;P'_y(X,&space;Y)[Q'_x,&space;\frac{N}{|N|}]&space;&plus;&space;P'_x(X,&space;Y)[\frac{N}{|N|},&space;Q'_y]&space;&plus;&space;P'_x(X,Y)&space;P'_y(X,Y)[N,&space;(\frac{N}{|N|})^2]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?N_n&space;=&space;[Q'_nx,&space;Q'_ny]&space;&plus;&space;P'_y(X,&space;Y)[Q'_x,&space;\frac{N}{|N|}]&space;&plus;&space;P'_x(X,&space;Y)[\frac{N}{|N|},&space;Q'_y]&space;&plus;&space;P'_x(X,Y)&space;P'_y(X,Y)[N,&space;(\frac{N}{|N|})^2]" title="N_n = [Q'_nx, Q'_ny] + P'_y(X, Y)[Q'_x, \frac{N}{|N|}] + P'_x(X, Y)[\frac{N}{|N|}, Q'_y] + P'_x(X,Y) P'_y(X,Y)[N, (\frac{N}{|N|})^2]" /></a>

Учитывая, что первое слагаемое представляет собой нормаль к исходной поверхности, а последнее слагаемое равно нулю как векторное произведение коллинеарных векторов, окончательно получим:

<a href="https://www.codecogs.com/eqnedit.php?latex=N_n&space;=&space;N&space;&plus;&space;P'_y(X,&space;Y)[Q'_x,&space;\frac{N}{|N|}]&space;&plus;&space;P'_x(X,&space;Y)[\frac{N}{|N|},&space;Q'_y]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?N_n&space;=&space;N&space;&plus;&space;P'_y(X,&space;Y)[Q'_x,&space;\frac{N}{|N|}]&space;&plus;&space;P'_x(X,&space;Y)[\frac{N}{|N|},&space;Q'_y]" title="N_n = N + P'_y(X, Y)[Q'_x, \frac{N}{|N|}] + P'_x(X, Y)[\frac{N}{|N|}, Q'_y]" /></a>

Для моделирования искажений вводится шумовая функция **R(X,Y,Z)**, которая должна удовлетворять следующим требованиям:
* Она должна быть непрерывной;
* Принимать значения из интервала [0,1];
* Вести себя аналогично равномерно распределенной случайной величине.

Одним из способов задания такой функции является задание случайных значений в узлах некоторой регулярной сетки (в точках i, j, k, принадлежащих множеству целых чисел) и последующей интерполяции на все остальные точки. Для отыскания значения функции в произвольной точке сначала надо определить параллелепипед, содержащий данную точку внутри себя, затем, используя значения функции в вершинах параллелепипеда и проводя интерполяцию, найти значений функции в исходной точке. Для использования целочисленной решетки может быть предложено следующее задание функции:

<a href="https://www.codecogs.com/eqnedit.php?latex=R(X,Y,Z)&space;=&space;\sum_{i=|x|}^{|x|&plus;1}\sum_{j=|y|}^{|y|&plus;1}\sum_{k&plus;|z|}^{|z|&plus;1}\omega(|x-i|)\omega(|y-j)\omega(|z-K|)A_{ijk}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?R(X,Y,Z)&space;=&space;\sum_{i=|x|}^{|x|&plus;1}\sum_{j=|y|}^{|y|&plus;1}\sum_{k&plus;|z|}^{|z|&plus;1}\omega(|x-i|)\omega(|y-j)\omega(|z-K|)A_{ijk}" title="R(X,Y,Z) = \sum_{i=|x|}^{|x|+1}\sum_{j=|y|}^{|y|+1}\sum_{k+|z|}^{|z|+1}\omega(|x-i|)\omega(|y-j)\omega(|z-K|)A_{ijk}" /></a>

W(t) – одномерная весовая функция, в простейшем случае w(t) = t, t∈[0,1].

Использование приведенной трилинейной интерполяции дает не очень хорошие результаты, так как на границе параллелепипеда происходит разрыв первых производных, т.е. функция не является гладкой. Для достижения гладкости на функцию следует наложить условие W’(0) = W’(1) = 0. Простейшим вариантом функции, удовлетворяющей этому условию, является многочлен Эрмита:

<a href="https://www.codecogs.com/eqnedit.php?latex=\omega(t)&space;=&space;3t^2&space;-&space;2t^3,&space;t&space;\in&space;[0,1]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\omega(t)&space;=&space;3t^2&space;-&space;2t^3,&space;t&space;\in&space;[0,1]" title="\omega(t) = 3t^2 - 2t^3, t \in [0,1]" /></a>

Если функция возмущения не описывается аналитически, ее можно задать двумерной таблицей цветов. Промежуточные значения вычисляются билинейной интерполяцией табличных величин, а производные вычисляются методом конечных разностей.

**Следующий вопрос:**  [43. Глобальная модель освещения с трассировкой лучей.](./exam43)


**Предыдущий вопрос:**  [41. Учет прозрачности в модели освещения. Учет прозрачности в  алгоритмах удаления невидимых поверхностей.](./exam41)
